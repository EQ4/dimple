diff --git a/configure.ac b/configure.ac
index fd791dd..453281d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -39,7 +39,16 @@ AC_CHECK_PROG([DOXYGEN], [doxygen], [doc], [])
 AC_SUBST(DOXYGEN)
 
 # Checks for libraries.
-AC_CHECK_LIB([pthread], [pthread_create])
+AC_CHECK_LIB([pthread], [pthread_create], ,
+    # MingW: if pthreads needs wsock32,
+    # then we'll also need ws2_32
+    # By the way, this means we require Windows XP
+    # which is specified by setting WINVER=0x501.
+    [LIBS="$LIBS -lwsock32 -lws2_32"
+     unset ac_cv_lib_pthread_pthread_create
+     AC_CHECK_LIB([pthread], [pthread_create],
+         [AC_CHECK_HEADERS(ws2tcpip.h)],
+         [AC_MSG_ERROR([pthread required.])])])
 AC_SEARCH_LIBS([recvfrom], [socket])
 
 # Checks for header files.
diff --git a/src/address.c b/src/address.c
index f86f0b0..be8a7a6 100644
--- a/src/address.c
+++ b/src/address.c
@@ -21,7 +21,7 @@
 #include <sys/types.h>
 
 #ifdef WIN32
-#include <winsock2.h>
+#define WINVER 0x501
 #include <ws2tcpip.h>
 #else
 #include <netdb.h>
diff --git a/src/send.c b/src/send.c
index 5808dc3..010c0c8 100644
--- a/src/send.c
+++ b/src/send.c
@@ -27,7 +27,7 @@
 #include <sys/types.h>
 
 #ifdef WIN32
-#include <winsock2.h>
+#define WINVER 0x501
 #include <ws2tcpip.h>
 #else
 #include <netdb.h>
diff --git a/src/server.c b/src/server.c
index 13449eb..d8967aa 100644
--- a/src/server.c
+++ b/src/server.c
@@ -27,6 +27,9 @@
 #include <sys/types.h>
 
 #ifdef WIN32
+  #ifdef ENABLE_IPV6
+    #define _WIN32_WINNT 0x0501
+  #endif
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #define EADDRINUSE WSAEADDRINUSE
@@ -82,6 +85,7 @@ static lo_server lo_server_new_with_proto_internal(const char *group,
 // used by getaddrinfo().
 #define GAI_STRERROR_BUFFER_SIZE 1024
 
+#ifndef __GNUC__
 char *WSAAPI gai_strerrorA(int ecode)
 {
     DWORD dwMsgLen;
@@ -98,7 +102,7 @@ char *WSAAPI gai_strerrorA(int ecode)
                               NULL);
     return buff;
 }
-
+#endif
 
 static int stateWSock = -1;
 
@@ -281,12 +285,16 @@ lo_server lo_server_new_with_proto_internal(const char *group,
         struct ip_mreq mreq;
         unsigned int yes = 1;
         memset(&mreq, 0, sizeof(mreq));
-        if (inet_aton(group, &mreq.imr_multiaddr)==0) {
+#ifdef WIN32
+        mreq.imr_multiaddr.S_un.S_addr = inet_addr(group);
+#else
+        if (inet_addr(group, &mreq.imr_multiaddr)==0) {
             int err = geterror();
             lo_throw(s, err, strerror(err), "inet_aton()");
             lo_server_free(s);
             return NULL;
         }
+#endif
         mreq.imr_interface.s_addr=htonl(INADDR_ANY);
 
         setsockopt(s->socket,IPPROTO_IP,IP_ADD_MEMBERSHIP,&mreq,sizeof(mreq));
@@ -712,6 +720,7 @@ static void dispatch_method(lo_server s, const char *path,
 
     //inet_ntop(s->addr.ss_family, &s->addr.padding, hostname, sizeof(hostname));
     if (s->protocol == LO_UDP) {
+#ifdef ENABLE_IPV6
 	err = getnameinfo((struct sockaddr *)&s->addr, sizeof(s->addr),
 	    hostname, sizeof(hostname), portname, sizeof(portname),
 	    NI_NUMERICHOST | NI_NUMERICSERV);
@@ -743,6 +752,10 @@ static void dispatch_method(lo_server s, const char *path,
 	    default:
 		lo_throw(s, err, "Unknown error", path);
 		break;
+#else
+        struct hostent *h = gethostbyname(hostname);
+        s->addr = h->h_addr;
+#endif
 	    }
 
 	    return;
